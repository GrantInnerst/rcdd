
/*
 *  rcdd an R interface to cddlib
 *  Copyright (C) 2005    Charles J. Geyer
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  A copy of the GNU General Public License is available via WWW at
 *  http://www.gnu.org/copyleft/gpl.html.  You can also obtain it by
 *  writing to the Free Software Foundation, Inc., 59 Temple Place,
 *  Suite 330, Boston, MA  02111-1307  USA.
 */

#include <Rinternals.h>

static int set_subset(SEXP set1, SEXP set2);

SEXP nonred(SEXP sets)
{
    if (! isNewList(sets))
        error("argument not list");

    int n = LENGTH(sets);

#ifdef BLEAT
    printf("n = %d\n", n);
#endif /* BLEAT */

    for (int i = 0; i < n; ++i) {
        SEXP foo = VECTOR_ELT(sets, i);
        if (! isInteger(foo))
            error("argument not list of integer vectors");
    }

    SEXP result;
    PROTECT(result = allocVector(LGLSXP, n));

#ifdef BLEAT
    printf("LENGTH(result) = %d\n", LENGTH(result));
#endif /* BLEAT */

    for (int i = 0; i < n; ++i) {
        SEXP set1 = VECTOR_ELT(sets, i);
        LOGICAL(result)[i] = TRUE;
        for (int j = 0; j < n; ++j) {
            if (i != j && LOGICAL(result)[j]) {
                SEXP set2 = VECTOR_ELT(sets, j);
                int fred = set_subset(set1, set2);
                if (fred < 1) {
                    LOGICAL(result)[i] = FALSE;
                    break;
                }
            }
        }

    }

#ifdef BLEAT
    for (int i = 0; i < n; ++i)
        printf("result[%d] = %d\n", i, LOGICAL(result)[i]);
#endif /* BLEAT */

    UNPROTECT(1);
    return result;
}

static int set_subset(SEXP set1, SEXP set2)
{
    /*
    *  we've already checked that set1 and set2 are integer vectors
    *  return -1 if set1 is a proper subset of set2
    *  return  0 if set1 is equal to set2
    *  return  1 if set1 is not a subset of set2
    *
    *  intent:
    *      if -1 returned, then set1 is redundant
    *      if  0 returned, then one of set1 or set2 is redundant (keep only one)
    *      if  1 returned, then set1 is nonredundant (at least so far)
    */

    int n1 = LENGTH(set1);
    int n2 = LENGTH(set2);

    if (n1 == 0)
        return -1;
    if (n2 == 0)
        return 1;

    int s1_subset_s2 = TRUE;
    for (int i = 0; i < n1; ++i) {
        int e1 = INTEGER(set1)[i];
        int foo = FALSE;
        for (int j = 0; j < n2; ++j) {
            int e2 = INTEGER(set2)[j];
            if (e1 == e2) {
                foo = TRUE;
                break;
            }
        }
        if (! foo) {
            s1_subset_s2 = FALSE;
            break;
        }
    }

    if (! s1_subset_s2)
        return 1;

    int s2_subset_s1 = TRUE;
    for (int i = 0; i < n2; ++i) {
        int e2 = INTEGER(set2)[i];
        int foo = FALSE;
        for (int j = 0; j < n1; ++j) {
            int e1 = INTEGER(set1)[j];
            if (e1 == e2) {
                foo = TRUE;
                break;
            }
        }
        if (! foo) {
            s2_subset_s1 = FALSE;
            break;
        }
    }

    if (s2_subset_s1)
        return 0;
}

