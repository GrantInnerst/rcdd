
\documentclass{article}

\usepackage{indentfirst}
\usepackage{amsmath}

\RequirePackage{amsfonts}
\newcommand{\real}{\mathbb{R}}

\usepackage{/HOME/faculty/charlie/local/lib/R/share/texmf/Sweave}
\begin{document}

\title{Using the RCDD Package}
\author{Charles J. Geyer}
\maketitle

% \VignetteIndexEntry{Using RCDD}

\section{The Name of the Game}

We call the package \verb@rcdd@ which stands
for ``C Double Description in R,'' our name being copied from
\verb@cddlib@, the library we call to do the computations.
This library was written by Komei Fukuda and is available at
\begin{verbatim}
    http://www.cs.mcgill.ca/~fukuda/soft/cdd_home/
\end{verbatim}
Our \verb@rcdd@ package for R makes available some
(by no means all) of the functionality
of the \verb@cddlib@ library.

\section{Representations}

The two descriptions in question are the descriptions of a convex polyhedron
as either
\begin{itemize}
\item the intersection of a finite collection of closed half spaces or
\item the convex hull of of a finite collection of points and directions.
\end{itemize}

A \emph{direction} in $\real^d$ can be identified with
either a nonzero point $x$ or with
the ray $\{ \lambda x : \lambda \ge 0 \}$ generated by such a point.  
The \emph{convex hull} of a set of points $x_1$, $\ldots$, $x_k$ and
a set of directions represented as nonzero
points $x_{k + 1}$, $\ldots$, $x_m$ is the set of linear
combinations
$$
   x = \sum_{i = 1}^m \lambda_i x_i
$$
where the coefficients $\lambda_i$ satisfy
$$
   \lambda_i \ge 0, \qquad i = 1, \ldots, m
$$
and
$$
   \sum_{i = 1}^k \lambda_i = 1
$$
(note that only the $\lambda_i$ for points, not directions,
are in the latter sum).
The fact that these two descriptions characterize the same class of
convex sets (the \emph{polyhedral} convex sets) is Theorem~19.1
in Rockafellar (\emph{Convex Analysis}, Princeton University Press, 1970).
The points and directions are said to be \emph{generators} of the
convex polyhedron.  Those who like eponyms call this the
Minkowski-Weyl theorem
\begin{verbatim}
    http://www.ifor.math.ethz.ch/staff/fukuda/polyfaq/node14.html
\end{verbatim}

\subsection{The H-representation}

In the terminology of the \verb@cddlib@ documentation,
the two descriptions are called
the ``H-representation'' and the ``V-representation''
(``H'' for half space and ``V'' for vertex,
although, strictly speaking, generators are not always vertices).

For both efficiency and computational stability, the H-representation
allows not only closed half spaces but hyperplanes (which are, of course, the
intersection of two closed half spaces), or, what is equivalent,
the H-representation characterizes the convex polyhedron as the solution
set of a finite set of linear equalities and inequalities, that is,
the set of points $x$ satisfying
$$
   A_1 x \le b_1 \quad \text{and} \quad A_2 x = b_2
$$
where $A_1$ and $A_2$ are matrices and $b_1$ and $b_2$ are vectors
and the dimensions are such that these equations make sense.

In the representation used for our \verb@rcdd@ package
for R, these parts of the specification are combined into one big matrix
$$
   M = \begin{pmatrix} 0 & b_1 & - A_1 \\ 1 & b_2 & - A_2 \end{pmatrix}
$$
If the dimension of the space in which the polyhedron lives is $d$,
then $M$ has column dimension $d + 2$ and the first two columns are special.
The first column is an indicator vector, zero indicates an inequality
constraint and one an equality constraint.  The second column contains
the ``right hand side'' vectors $b_1$ and $b_2$.  Although we have given
an example in which all the inequality rows are on top of all the equality
rows, this is not required.  The rows can be in any order.

If \verb@m@ is such a matrix and we let
\begin{verbatim}
    l <- m[ , 1]
    b <- m[ , 2]
    a <- m[ , - c(1, 2)]
\end{verbatim}
then the convex polyhedron described is the set of points \verb@x@ that
satisfy
\begin{verbatim}
    axb <- a %*% x - b
    all(axb <= 0)
    all(l * axb == 0)
\end{verbatim}

\subsection{The V-representation}

For both efficiency and computational stability, the V-representation
allows not only points and directions, but also lines and something I
don't know the name of (perhaps ``affine generators'').

In R a V-representation is matrix with the same column dimension as
the corresponding H-representation, and again the first two columns
are special,
but their interpretation is different.  Now the first two columns
are both indicators (zero or one valued).  The rest of each row
represents a point.

The convex polyhedron described is the set of linear combinations of
these points such that the coefficients are (1) nonnegative if
column one is zero and (2) sum to one where the sum runs over
rows having a one in column two.

If \verb@m@ is such an object and we define \verb@a@, \verb@b@, and
\verb@l@ as in the preceding section (\verb@l@ is column one, \verb@b@ is
column two, and \verb@a@ is the rest), then the polyhedron in question
is the set of points of the form
\begin{verbatim}
    y <- t(lambda) %*% a
\end{verbatim}
where \verb@lambda@ satisfies the constraints
\begin{verbatim}
    all(lambda * (1 - l) >= 0)
    sum(b * lambda) == max(b)
\end{verbatim}

\subsection{Fukuda's Representations}

Readers interested in comparing with Fukuda's documentation should be
aware that \verb@cddlib@ uses different but mathematically equivalent
representations.
If our representation is a matrix \verb@m@, then Fukuda's representation
consists of a matrix, which is our \verb@m[ , -1]@ and a vector
(which he calls the \emph{linearity}), which is our
\verb@seq(1, nrow(m))[m[ , 1] == 1]@
(that is the vector of indices of the rows having a one in our column one).

\section{Trying it Out}

\subsection{A Unit Simplex}

Let's try a really simple example, so we can see what's going on:
the unit simplex in $\real^3$ (essentially copied from the \verb@scdd@
help page, never mind how \verb@makeH@ works, just look that the matrix
\verb@qux@ that it produces, which is an H-representation).
\begin{Schunk}
\begin{Sinput}
> library(rcdd)
> d <- 3
> qux <- makeH(-diag(d), rep(0, d), rep(1, d), 1)
> print(qux)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1   -1   -1   -1
[2,]    0    0    1    0    0
[3,]    0    0    0    1    0
[4,]    0    0    0    0    1
attr(,"representation")
[1] "H"
\end{Soutput}
\end{Schunk}
The first row represents the equality constraint \verb@sum(x) == 1@
and the other three rows represent the inequality constraints \verb@x[i] >= 0@
for \verb@i@ in \verb@1:d@.
\begin{Schunk}
\begin{Sinput}
> out <- scdd(qux)
> print(out)
\end{Sinput}
\begin{Soutput}
$output
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1    0    0    1
[2,]    0    1    0    1    0
[3,]    0    1    1    0    0
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}
The corresponding V-representation has 3 vertices,
$(1, 0, 0)$, $(0, 1, 0)$, $(0, 0, 1)$.
\begin{Schunk}
\begin{Sinput}
> out <- scdd(out$output)
> print(out)
\end{Sinput}
\begin{Soutput}
$output
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1   -1   -1    0
[2,]    0    0    1    0    0
[3,]    0    0    0    1    0
[4,]    1   -1    1    1    1
attr(,"representation")
[1] "H"
\end{Soutput}
\end{Schunk}
Note that \verb@scdd@ goes both ways.  If we toggle back,
we get a different H-representation, but one that still
represents the unit simplex.

\subsection{Adding a Constraint}

Now let us complicate the situation a bit.  The unit simplex represents
possible probability vectors.  Let us say the points in the state space
are \verb@x <- 1:d@ and we the elements of the unit simplex are probability
vectors \verb@p@ and we want to add the equality constraint
\verb@sum(p * x) == 2.2@.
\begin{Schunk}
\begin{Sinput}
> quux <- addHeq(1:d, 2.2, qux)
> print(quux)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5]
[1,]    1  1.0   -1   -1   -1
[2,]    0  0.0    1    0    0
[3,]    0  0.0    0    1    0
[4,]    0  0.0    0    0    1
[5,]    1  2.2   -1   -2   -3
attr(,"representation")
[1] "H"
\end{Soutput}
\begin{Sinput}
> out <- scdd(quux)
> print(out)
\end{Sinput}
\begin{Soutput}
$output
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1  0.4  0.0  0.6
[2,]    0    1  0.0  0.8  0.2
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}
Adding the equality constraint takes us down a dimension.  The unit
simplex was two-dimensional (a triangle).  Now the represented convex
polyhedron is one-dimensional (a line segment).

\subsection{Convex Hull}

Let's try to find convex hulls in \verb@d@ dimensions.
\begin{Schunk}
\begin{Sinput}
> d <- 4
> n <- 100
> set.seed(42)
> x <- matrix(rnorm(d * n), nrow = n)
> foo <- cbind(0, cbind(1, x))
> outh <- scdd(foo, inputincidence = TRUE, representation = "V")
> inies <- sapply(outh$inputincidence, length) == 0
> sum(inies)
\end{Sinput}
\begin{Soutput}
[1] 60
\end{Soutput}
\end{Schunk}
The points on the surface of the convex hull are the rows
of \verb@x[! inies, ]@.
(The code in \verb@cddlib@ provides a faster way to do this, but \verb@rcdd@
does not currently provide an interface to it.)

\section{Using GMP Rational Arithmetic} \label{sec:gmp}

\subsection{A Simple Example}

The \verb@cddlib@ code can also use the GMP (GNU Multiple Precision) Library
to compute results using exact arithmetic with unlimited precision rational
numbers and we bring this facility to \verb@rcdd@ as well.

In order to use rational arithmetic, we need a rational number format.
Adding a new numeric type to R would be a job of horrendous complexity,
so we don't even try.  We just use the representation of the rational
as a character string, e.~g., \verb@"3/4"@ or \verb@"-15/32"@.
\begin{Schunk}
\begin{Sinput}
> quuxq <- d2q(quux)
> print(quuxq)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]                                [,3] [,4] [,5]
[1,] "1"  "1"                                 "-1" "-1" "-1"
[2,] "0"  "0"                                 "1"  "0"  "0" 
[3,] "0"  "0"                                 "0"  "1"  "0" 
[4,] "0"  "0"                                 "0"  "0"  "1" 
[5,] "1"  "2476979795053773/1125899906842624" "-1" "-2" "-3"
attr(,"representation")
[1] "H"
\end{Soutput}
\end{Schunk}
What is that?  Well computers count in binary and 2.2 is
\emph{not} a round number to computers (because $1/10$ is not a power of 2).
We can see that the rational representation does make sense
\begin{Schunk}
\begin{Sinput}
> bar <- as.numeric(unlist(strsplit(quuxq[5, 2], "/")))
> print(bar)
\end{Sinput}
\begin{Soutput}
[1] 2.47698e+15 1.12590e+15
\end{Soutput}
\begin{Sinput}
> bar[1]/bar[2]
\end{Sinput}
\begin{Soutput}
[1] 2.2
\end{Soutput}
\end{Schunk}
But we don't want to check our rational approximations that way
because (1) it's a pain and (2) big integers needn't be
exactly represented either.  So if you're willing to take
\verb@rcdd@'s word for it
\begin{Schunk}
\begin{Sinput}
> q2d(quuxq)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5]
[1,]    1  1.0   -1   -1   -1
[2,]    0  0.0    1    0    0
[3,]    0  0.0    0    1    0
[4,]    0  0.0    0    0    1
[5,]    1  2.2   -1   -2   -3
attr(,"representation")
[1] "H"
\end{Soutput}
\end{Schunk}

But that was just a preliminary explanation.  The point is that \verb@scdd@
uses rational representations like \verb@quuxq@ just as well as (better
actually) inexact floating point representations like \verb@quux@.
\begin{Schunk}
\begin{Sinput}
> outq <- scdd(quuxq)
> print(outq)
\end{Sinput}
\begin{Soutput}
$output
     [,1] [,2] [,3]                              
[1,] "0"  "1"  "900719925474099/2251799813685248"
[2,] "0"  "1"  "0"                               
     [,4]                               [,5]                               
[1,] "0"                                "1351079888211149/2251799813685248"
[2,] "900719925474099/1125899906842624" "225179981368525/1125899906842624" 
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}
Oops!  Excuse the verbose mess.
\begin{Schunk}
\begin{Sinput}
> print(q2d(outq$output))
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1  0.4  0.0  0.6
[2,]    0    1  0.0  0.8  0.2
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}

But that too, was not exactly what I wanted to present.
It's not rational arithmetic that is really messy here,
but floating point!  Let's make the rational approximation
to be exactly what we wanted.
\begin{Schunk}
\begin{Sinput}
> quuxq <- z2q(round(quux * 10), rep(10, length(quux)))
> print(quuxq)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]   [,3] [,4] [,5]
[1,] "1"  "1"    "-1" "-1" "-1"
[2,] "0"  "0"    "1"  "0"  "0" 
[3,] "0"  "0"    "0"  "1"  "0" 
[4,] "0"  "0"    "0"  "0"  "1" 
[5,] "1"  "11/5" "-1" "-2" "-3"
attr(,"representation")
[1] "H"
\end{Soutput}
\begin{Sinput}
> outq <- scdd(quuxq)
> print(outq)
\end{Sinput}
\begin{Soutput}
$output
     [,1] [,2] [,3]  [,4]  [,5] 
[1,] "0"  "1"  "2/5" "0"   "3/5"
[2,] "0"  "1"  "0"   "4/5" "1/5"
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}
Now we have a nice exact representation.  It's the floating
point stuff that is wrong.
\begin{Schunk}
\begin{Sinput}
> qmq(outq$output, out$output)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3]                   [,4]                  
[1,] "0"  "0"  "13/90071992547409920" "0"                   
[2,] "0"  "0"  "0"                    "13/45035996273704960"
     [,5]                  
[1,] "-1/11258999068426240"
[2,] "-1/5629499534213120" 
attr(,"representation")
[1] "V"
\end{Soutput}
\end{Schunk}

\subsection{A More Complicated Example}

Let's check our convex hull calculation.
\begin{Schunk}
\begin{Sinput}
> outhq <- scdd(d2q(foo), inputincidence = TRUE, representation = "V")
> iniesq <- sapply(outhq$inputincidence, length) == 0
> all.equal(inies, iniesq)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> nrow(outh$output) == nrow(outhq$output)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> outh <- scdd(foo, incidence = TRUE, representation = "V")
> outhq <- scdd(d2q(foo), incidence = TRUE, representation = "V")
> all.equal(outh$incidence, outhq$incidence)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}
So we happened to get the same number of points on the surface of the
hull.  And we got the same number of facets of the convex polyhedron,
and they all had the same shape.  The inexactness of floating point
arithmetic didn't hurt us this time.  But if you put this in a loop
doing simulations, eventually you will get wrong answers with floating
point.  Or worse, \verb@scdd@ will just give up on the problem being
unable to decide whether a point is inside or on the surface of the
hull (or whatever).  An example of this is in \verb@rcdd/tests/oops.R*@
where the problem in \verb@oops.RData@ does make \verb@scdd@ fail
unless rational arithmetic is used.  This problem arose in a simulation
done by Glen Meeden.

\end{document}


