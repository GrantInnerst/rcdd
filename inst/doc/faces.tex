
\documentclass{article}

\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\set}[1]{\{\, #1 \,\}}
\newcommand{\bigset}[1]{\left\{\, #1 \,\right\}}
\newcommand{\inner}[1]{\langle #1 \rangle}

\newcommand{\mdot}{\,\cdot\,}

\newcommand{\real}{\mathbb{R}}

\begin{document}

\title{Faces in the RCDD Package}
\author{Charles J. Geyer}
\maketitle

\section{Introduction}

\subsection{Polyhedral Convex Sets}

A \emph{polyhedral convex set} is a set of the form
\begin{equation} \label{eq:h}
   C = \set{ x \in \real^d : \inner{a_i, x} \le b_i, i \in I \ \text{and}
               \ \inner{a_i, x}  =  b_i, i \in E }
\end{equation}
where $\inner{\mdot, \mdot}$ denotes the inner product and $I$ and $E$
are disjoint finite sets.

\subsection{Faces}

The \emph{faces} of a polyhedral convex set $C$ are sets of the form
\begin{equation} \label{eq:face}
   F = \bigset{ x \in C : \inner{a, x} = \sup_{y \in C} \inner{a, y} }
\end{equation}
where $\inner{\mdot, \mdot}$ denotes inner product, plus perhaps the
empty set if it is not given by \eqref{eq:face} for some $a$.

The \emph{improper faces} are $C$ itself and the empty set.
All the rest are \emph{proper faces}.  Proper faces of maximal
dimension (one less than the dimension of $C$) are called \emph{facets}.
Proper faces of minimal dimension are called \emph{vertices}.

\subsection{Representations}

The representation \eqref{eq:h} is called an H-representation
(H for half space) in CDD terminology.  It is a theorem, sometimes
called the Minkowski-Weyl theorem that and convex polyhedron also
can be represented as the convex hull of a finite set of points
and directions, this means it consists of points of the form
$$
   \sum_{i \in P \cup D} a_i x_i
$$
where again $P$ and $D$ are finite sets, the $x_i$ are points in $\real^d$
and the $a_i$ are nonnegative scalars such that
$$
   \sum_{i \in P} a_i = 1.
$$
This representation s called a V-representation
(V for vertex) in CDD terminology.  The V is something of a misnomer,
because the $x_i$ are only vertices when there are no directions
(when $D$ is empty).  The general term is \emph{generators}, but we
still use the term V-representation.

CDD adds (for computational simplicity) two additional kinds of generators.
Its V-representation consists of points of the form
$$
   \sum_{i \in P \cup D \cup L \cup Q} a_i x_i
$$
where now we require only
$$
   a_i \ge 0, \qquad i \in P \cup D
$$
and
$$
   \sum_{i \in P \cup Q} a_i = 1
$$
$L$ and $Q$ also being finite sets.  The term for generators in $L$
is \emph{lines}, and I don't have a term for generators in $Q$.

\begin{center} \LARGE REVISED DOWN TO HERE \end{center}


Suppose we have an H-representation
and a V-representation (that is we have run \verb@scdd@ and saved the input)
the primary vectors $a$ of interest are those found in the H-representation.
The \verb@rcdd@ form of an H-representation is a matrix
$$
   M = \begin{pmatrix} 0 & b_1 & - A_1 \\ 1 & b_2 & - A_2 \end{pmatrix}
$$
and represents the set
$$
   C = \set{ x \in \real^d : A_1 x \le b_1 \ \text{and} \ A_2 x = b_2 }.
$$

Let us replace it with
here $E$ and $I$ are disjoint finite sets and the $a_i$ are the rows
of $A_1$ and $A_2$ (for $i$ in $I$ and $E$ respectively) and the $b_i$
are the corresponding elements of $b_1$ and $b_2$.

Now consider \eqref{eq:face} where $a$ is arbitrary.
I claim the following
$$
   F = \set{ x \in C : \inner{a_i, x} = b_i, i \in A }
$$
where $A$ (the so-called \emph{active} constraint set) in two
stages by
$$
   \widetilde{I} = \bigset{ i \in I : \sup_{x \in C} \inner{a_i, x} = b_i }
$$
and
$$
   A = \set{ i \in \widetilde{I} : \inner{a_i, a} > 0 }
$$
(if $A$ is empty, then $F = C$, an improper face).

\end{document}



\documentclass{article}

\usepackage{indentfirst}
\usepackage{amsmath}

\RequirePackage{amsfonts}
\newcommand{\real}{\mathbb{R}}

\RequirePackage{amsmath}
\DeclareMathOperator{\lin}{lin}
\DeclareMathOperator{\aff}{aff}
\DeclareMathOperator{\pos}{pos}
\DeclareMathOperator{\con}{con}

\newcommand{\opand}{\mathbin{\rm and}}
\newcommand{\set}[1]{\{\, #1 \,\}}

\begin{document}

\title{Design of the RCDD Package}
\author{Charles J. Geyer}
\maketitle

\section{The Name of the Game}

We have called the package \verb@rcdd@ which stands
for ``C Double Description in R,'' our name being copied from
\verb@cddlib@, the library we call to do the computations.
This library was written by Komei Fukuda and is available at
\begin{verbatim}
    http://www.cs.mcgill.ca/~fukuda/soft/cdd_home/
\end{verbatim}
Our \verb@rcdd@ package for R makes available some
(by no means all) of the functionality
of the \verb@cddlib@ library.

The ``C'' is for either of the C or C++ computer languages.
This is bad terminology, making a mere implementation detail
part of the name, but we keep Fukuda's name.

The two descriptions in question are the descriptions of a convex polyhedron
as either
\begin{itemize}
\item the intersection of a finite collection of closed half spaces or
\item the convex hull of of a finite collection of points and directions.
\end{itemize}

For those readers who are not familiar with the second description,
we give more detail.  We assume the notion of a point in $\real^d$
is familiar.  A \emph{direction} in $\real^d$ can be identified with
either a nonzero point $x$ or with
the ray $\{ \lambda x : \lambda \ge 0 \}$ generated by such a point.  
The \emph{convex hull} of a set of points $x_1$, $\ldots$, $x_k$ and
a set of directions represented as nonzero
points $x_{k + 1}$, $\ldots$, $x_m$ is the set of linear
combinations
$$
   x = \sum_{i = 1}^m \lambda_i x_i
$$
where the coefficients $\lambda_i$ satisfy
$$
   \lambda_i \ge 0, \qquad i = 1, \ldots, m
$$
and
$$
   \sum_{i = 1}^k \lambda_i = 1
$$
(note that only the $\lambda_i$ for points, not directions,
are in the latter sum).
The fact that these two descriptions characterize the same class of
convex sets (the \emph{polyhedral} convex sets) is Theorem~19.1
in Rockafellar (\emph{Convex Analysis}, Princeton University Press, 1970).
The points and directions are said to be \emph{generators} of the
convex polyhedron.  Those who like eponyms call this the
Minkowski-Weyl theorem
\begin{verbatim}
    http://www.ifor.math.ethz.ch/staff/fukuda/polyfaq/node14.html
\end{verbatim}
For more on this theorem, see Section~\ref{sec:more} below.

\section{Representations}

\subsection{The H-representation}

In the terminology of the \verb@cddlib@ documentation,
the two descriptions are called
the ``H-representation'' and the ``V-representation''
(``H'' for half space and ``V'' for vertex,
although, strictly speaking, generators are not always vertices).

For both efficiency and computational stability, the H-representation
allows not only closed half spaces but hyperplanes (which are, of course, the
intersection of two closed half spaces), or, what is equivalent,
the H-representation characterizes the convex polyhedron as the solution
set of a finite set of linear equalities and inequalities, that is,
the set of points $x$ satisfying
$$
   A_1 x \le b_1 \quad \text{and} \quad A_2 x = b_2
$$
where $A_1$ and $A_2$ are matrices and $b_1$ and $b_2$ are vectors
and the dimensions are such that these equations make sense.

In the representation used for our \verb@rcdd@ package
for R, these parts of the specification are combined into one big matrix
$$
   M = \begin{pmatrix} 0 & b_1 & - A_1 \\ 1 & b_2 & - A_2 \end{pmatrix}
$$
If the dimension of the space in which the polyhedron lives is $d$,
then $M$ has column dimension $d + 2$ and the first two columns are special.
The first column is an indicator vector, zero indicates an inequality
constraint and one an equality constraint.  The second column contains
the ``right hand side'' vectors $b_1$ and $b_2$.  Although we have given
an example in which all the inequality rows are on top of all the equality
rows, this is not required.  The rows can be in any order.

If \verb@m@ is such a matrix and we let
\begin{verbatim}
    l <- m[ , 1]
    b <- m[ , 2]
    a <- m[ , - c(1, 2)]
\end{verbatim}
then the convex polyhedron described is the set of points \verb@x@ that
satisfy
\begin{verbatim}
    axb <- a %*% x - b
    all(axb <= 0)
    all(l * axb == 0)
\end{verbatim}

\subsection{The V-representation}

For both efficiency and computational stability, the V-representation
allows not only points and directions, but also lines and something I
don't know the name of (perhaps ``affine generators,''
see Section~\ref{sec:more} below).

In R a V-representation is matrix with the same column dimension as
the corresponding H-representation, and again the first two columns
are special,
but their interpretation is different.  Now the first two columns
are both indicators (zero or one valued).  The rest of each row
represents a point.

The convex polyhedron described is the set of linear combinations of
these points such that the coefficients are (1) nonnegative if
column one is zero and (2) sum to one where the sum runs over
rows having a one in column two.

If \verb@m@ is such an object and we define \verb@a@, \verb@b@, and
\verb@l@ as in the preceding section (\verb@l@ is column one, \verb@b@ is
column two, and \verb@a@ is the rest), then the polyhedron in question
is the set of points of the form
\begin{verbatim}
    y <- t(lambda) %*% a
\end{verbatim}
where \verb@lambda@ satisfies the constraints
\begin{verbatim}
    all(lambda * (1 - l) >= 0)
    sum(b * lambda) == max(b)
\end{verbatim}

\subsection{More On V-Representations} \label{sec:more}

In convex geometry four different kinds of linear combinations are important.
\begin{itemize}
\item a \emph{linear combination} of a set of points
    $x_1$, $\ldots$, $x_n$ is $a_1 x_1 + \cdots + a_n x_n$,
    where $a_1$, $\ldots$, $a_n$ are arbitrary scalars called the
    \emph{coefficients}.
\item an \emph{affine combination} is a linear combination in which
    the coefficients sum to one.
\item a \emph{nonnegative combination} is a linear combination in which
    the coefficients are nonnegative.
\item a \emph{convex combination} is a linear combination that is
    both an affine combination and a nonnegative combination.
\end{itemize}

Collections of combinations are called hulls.
\begin{itemize}
\item the \emph{linear hull} of a nonempty set of points is the set of all
    linear combinations of nonempty finite subsets of those points
    (also called the \emph{span} of the points or
    the \emph{subspace generated by} the points).
    The linear hull of the empty set is the zero subspace $\{0\}$.
    The linear hull of $S$ is denoted $\lin(S)$.
\item the \emph{affine hull} of a nonempty set of points is the set of all
    affine combinations of nonempty finite subsets of those points.
    The affine hull of the empty set is the empty set.
    The affine hull of $S$ is denoted $\aff(S)$.
\item the \emph{positive hull} of a nonempty set of points is the set of all
    nonnegative combinations of nonempty finite subsets of those points
    (also called the the \emph{cone generated by} the points).
    The positive hull of the empty set is the zero cone $\{0\}$.
    The positive hull of $S$ is denoted $\pos(S)$.
\item the \emph{convex hull} of a nonempty set of points is the set of all
    convex combinations of nonempty finite subsets of those points.
    The convex hull of the empty set is the empty set.
    The convex hull of $S$ is denoted $\con(S)$.
\end{itemize}

These four types of combinations correspond to the four types of rows
of a V-representation.  Call a row \emph{zero-zero} if it has a zero
in column one and a zero in column two, \emph{zero-one} if it has a zero
in column one and a one in column two, and so forth.  Let
\begin{itemize}
\item $L$ be the set of the points in the one-zero rows,
\item $A$ be the set of the points in the one-one rows,
\item $C$ be the set of the points in the zero-zero rows,
\item $K$ be the set of the points in the zero-one rows,
\end{itemize}
Then the convex polyhedron represented by this V-representation is
$$
   \lin(L) + \pos(C) + \con\bigl(\aff(A) \cup \con(K)\bigr)
$$
where $+$ here denotes the Minkowski sum of sets
$$
   U + V = \set{ u + v : u \in U \opand v \in V }
$$
assuming all three summands are nonempty.  Otherwise, it is the
Minkowski sum of the nonempty summands.

Note that the Minkowski-Weyl theorem says that every convex polyhedron
can be represented as
$$
   \pos(C) + \con(K)
$$
where $C$ and $K$ are finite sets of points,
assuming both summands are nonempty, and otherwise
as either $\pos(C)$ or $\con(K)$.  So the sets $L$ and $A$ are
mere conveniences (but also improve computational stability when using
inexact arithmetic).

\subsection{Fukuda's Representations}

Readers interested in comparing with Fukuda's documentation should be
aware that \verb@cddlib@ uses different but mathematically equivalent
representations.
If our representation is a matrix \verb@m@, then Fukuda's representation
consists of a matrix, which is our \verb@m[ , -1]@ and a vector
(which he calls the \emph{linearity}), which is our
\verb@seq(1, nrow(m))[m[ , 1] == 1]@
(that is the vector of indices of the rows having a one in our column one).

\section{Converting Between Representations}

The R function \verb@scdd@ converts H-representations to V-representations
and vice versa.
The result is a list that
always contains a component \verb@output@ which is the
computed representation and may contain a component \verb@input@ which is
the input representation (depending on an argument \verb@keepinput@,
about which see below).

Other options involve auxiliary computations, any of the arguments
\begin{verbatim}
    adjacency = TRUE
    incidence = TRUE
    inputadjacency = TRUE
    inputincidence = TRUE
\end{verbatim}
(the defaults are \verb@FALSE@)
produce additional results, which are components of the list returned
by \verb@scdd@ having the same name as the argument (\verb@adjacency@
and so forth).  Each is a ragged array: \verb@adjacency[[i]][j]@
(note the brackets) says that the \verb@i@-th and \verb@j@-th rows
of the \verb@output@ are ``adjacent'', and so forth.  See
\begin{verbatim}
    http://www.cs.mcgill.ca/~fukuda/soft/cddman/node4.html
\end{verbatim}
for more about these.

The result contains a component \verb@input@ if
\begin{verbatim}
    keepinput = "TRUE"
\end{verbatim}
or if
\begin{verbatim}
    keepinput = "maybe"
\end{verbatim}
and the input is involved in an adjacency or incidence list
(the default is \verb@"maybe"@).

The last option involves the computation itself.
The \verb@roworder@ option specifies the order in which the rows of $M$
are processed which can have a considerable effect on the running time
of the algorithm and, when using normal floating point arithmetic
(see Section~\ref{sec:gmp} below), on the numerical results of the
algorithm or even on success or failure of the algorithm.  This argument
is a finite choice
\begin{verbatim}
rowoder = c("lexmin", "lexmax", "minindex", "maxindex",
    "mincutoff", "maxcutoff", "mixcutoff", "randomrow")
\end{verbatim}
and \verb@match.arg@ is used for the argument matching, so
(1) the argument may be abbreviated and (2) the default is \verb@"lexmin"@
if no argument is specified.
\begin{verbatim}
http://www.cs.mcgill.ca/~fukuda/soft/cddman/node4.html
http://www.cs.mcgill.ca/~fukuda/soft/cddlibman/node6.html
\end{verbatim}
contain some discussion of which to use.  The main bit of advice seems
to be that \verb@roworder = "maxcut"@ might be useful when an input
H-representation contains many redundant inequalities or an input
V-representation contains many interior points.

\section{Using GMP Rational Arithmetic} \label{sec:gmp}

The \verb@cddlib@ code can also use the GMP (GNU Multiple Precision) Library
to compute results using exact arithmetic with unlimited precision rational
numbers.

In order to do this, the input problem must be in this form.  Thus we
need a way to specify rational numbers.  We specify them as character
objects of the following form: an optional minus sign followed by an
integer (the \emph{numerator}), followed by a slash, followed by another
integer (the \emph{denominator}).  If the denominator is one, both it
and the slash may be omitted.  The string contains no whitespace.

\pagebreak[1]
All of
\begin{verbatim}
    1/3
    -5/7
    2
    123456789012345567890123456789/33
\end{verbatim}
are valid.  Note that the last is not exactly representable as an
ordinary floating point number (for that matter neither are $1 / 3$
and $- 5 / 7$).  The point of the long example is to point out that
integers of any size are allowed.  The numerator and denominator do
not have to be representable as ordinary computer integers.

We have two functions \verb@d2q@ and \verb@q2d@ that convert from
standard floating point (\verb@storage.mode@ \verb@"double"@ in R)
to rational and vice versa.  One can also construct rationals
from numerators and denominators using the \verb@z2q@ function.


\end{document}

